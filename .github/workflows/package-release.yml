name: Package and Release
env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
on:
  workflow_dispatch:
    inputs:
      ref:
        description: 'Git ref to checkout (tag or branch)'
        required: true
      previous:
        description: 'Previous ref/tag'
        required: true
      source_branch:
        description: 'Source branch to merge back to (e.g., v0.5.x or main)'
        required: false
        default: ''
jobs:
  package-deb:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [amd64, arm64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.inputs.ref }}
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23.x'
      - name: Run go generate
        run: |
          set -x
          go generate -v ./internal/myhome/ui/...
          go generate -v ./...
          ls -la internal/myhome/ui/static/bulma.min.css || echo "bulma.min.css not found!"
      - name: Extract tag name
        id: extract-tag
        run: |
          # Extract tag name from ref (e.g., refs/tags/v0.5.9 -> v0.5.9)
          REF="${{ github.event.inputs.ref }}"
          TAG_NAME=$(echo "$REF" | sed -E 's|^refs/tags/||')
          echo "tag=${TAG_NAME}" | tee -a "$GITHUB_OUTPUT"
      - id: go-releaser
        name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v6
        with:
          # either 'goreleaser' (default) or 'goreleaser-pro'
          distribution: goreleaser
          # 'latest', 'nightly', or a semver
          version: '~> v2'
          args: release -f .goreleaser.yml --clean --skip=publish
        env:
          GORELEASER_CURRENT_TAG: ${{ steps.extract-tag.outputs.tag }}
      - id: version
        name: Get package version from ref
        run: |
          # Extract version from the ref input (e.g., refs/tags/v0.5.9 -> 0.5.9)
          REF="${{ github.event.inputs.ref }}"
          VERSION=$(echo "$REF" | sed -E 's|^refs/tags/v*(.*)$|\1|g')
          echo "release=${VERSION}" | tee -a "$GITHUB_OUTPUT"
      - name: Shape artifacts
        id: shape-artifacts
        run: |
          echo '${{ steps.go-releaser.outputs.artifacts }}' | jq
          entry=$(echo '${{ steps.go-releaser.outputs.artifacts }}' | jq -cr '.[] | select(.name == "myhome" and .goarch == "${{ matrix.arch }}") | .')
          file=$(echo $entry | jq -cr '.name')-${{ steps.version.outputs.release }}-$(echo $entry | jq -cr '.goos')-$(echo $entry | jq -cr '.goarch')
          cp $(echo $entry | jq -cr '.path') $file
          echo "binary=$file" | tee -a $GITHUB_OUTPUT
      - name: Validate binary version
        if: matrix.arch == 'amd64'
        run: |
          set -euo pipefail
          EXPECTED_VERSION="${{ steps.extract-tag.outputs.tag }}"
          BINARY_PATH="./${{ steps.shape-artifacts.outputs.binary }}"
          
          # Make binary executable
          chmod +x "$BINARY_PATH"
          
          # Get version from binary
          VERSION=$("$BINARY_PATH" version)
          
          echo "Expected version: $EXPECTED_VERSION"
          echo "Actual version: $VERSION"
          
          # Normalize versions for comparison (strip 'v' prefix if present)
          EXPECTED_NORMALIZED="${EXPECTED_VERSION#v}"
          VERSION_NORMALIZED="${VERSION#v}"
          
          # Check if versions match (with or without 'v' prefix)
          if [[ "$VERSION_NORMALIZED" == "$EXPECTED_NORMALIZED" ]]; then
            echo "✓ Binary version validation passed"
          else
            echo "✗ Binary version validation failed: expected $EXPECTED_NORMALIZED but got $VERSION_NORMALIZED" >&2
            exit 1
          fi
      - id: prepare-deb
        name: Prepare package content
        run: |
          # main program
          mkdir -p .debpkg/usr/bin
          cp ${{ steps.shape-artifacts.outputs.binary }} .debpkg/usr/bin/myhome

          # systemd units
          mkdir -p .debpkg/lib/systemd/system/
          cp linux/systemd/myhome.service .debpkg/lib/systemd/system/
          cp linux/systemd/myhome-update.service .debpkg/lib/systemd/system/
          cp linux/systemd/myhome-update.timer .debpkg/lib/systemd/system/
          cp linux/systemd/myhome-db-backup.service .debpkg/lib/systemd/system/
          cp linux/systemd/myhome-db-backup.timer .debpkg/lib/systemd/system/

          # helper scripts
          mkdir -p .debpkg/usr/share/myhome
          cp linux/systemd/update.sh .debpkg/usr/share/myhome/update.sh
          cp linux/systemd/myhome-db-backup.sh .debpkg/usr/share/myhome/myhome-db-backup.sh
          chmod +x .debpkg/usr/share/myhome/*.sh

          # DEBIAN maintainer scripts
          mkdir -p .debpkg/DEBIAN
          cp linux/debian/postinst.sh .debpkg/DEBIAN/postinst
          cp linux/debian/prerm.sh .debpkg/DEBIAN/prerm
          cp linux/debian/postrm.sh .debpkg/DEBIAN/postrm
          chmod +x .debpkg/DEBIAN/postinst .debpkg/DEBIAN/prerm .debpkg/DEBIAN/postrm
      - id: build-deb
        name: Build Debian Package
        uses: jiro4989/build-deb-action@v4
        with:
          package: myhome
          package_root: .debpkg
          maintainer: Francois-Xavier 'FiX' KOWALSKI <fix.kowalski@gmail.com>
          # `https://hub.docker.com/r/jiro4989/build-deb-action` wants format like version: refs/tags/v*.*.*
          version: refs/tags/${{ steps.version.outputs.release }}
          arch: '${{ matrix.arch }}'
          depends: 'libc6 (>= 2.2.1), systemd, jq, curl' # optional
          desc: 'MyHome Automation.' # optional
          homepage: 'https://github.com/asnowfix/home-automation' # optional
      - name: Upload MyHome DEB as artifact
        uses: actions/upload-artifact@v4
        with:
          name: deb_file_${{ matrix.arch }}
          path: ${{ steps.build-deb.outputs.file_name }}
  package-msi:
    runs-on: windows-latest
    outputs:
      release_version: ${{ steps.version.outputs.release }}
      installer_file: ${{ steps.build-installer.outputs.installer_file }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.inputs.ref }}
      - id: version
        name: Get package version from ref
        run: |
          # Extract version from the ref input (e.g., refs/tags/v0.5.9 -> 0.5.9)
          $ref = "${{ github.event.inputs.ref }}"
          $tag = $ref -replace '^refs/tags/v*',''
          Add-Content -Path $env:GITHUB_OUTPUT -Value "release=$tag"
          $version = $tag -split '\.'
          Add-Content -Path $env:GITHUB_OUTPUT -Value "version_major=$($version[0])"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "version_minor=$($version[1])"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "version_patch=$($version[2])"
      - id: install-go
        name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: 1.23.0
      - name: Run go generate
        run: |
          go generate -v ./internal/myhome/ui/...
          go generate -v ./...
          if (Test-Path internal/myhome/ui/static/bulma.min.css) { ls internal/myhome/ui/static/bulma.min.css } else { Write-Host "bulma.min.css not found!" }
      - id: build
        name: Build Windows Exectutable
        run: go build -o "myhome.exe" ".\\myhome"
      - name: Install ImageMagick
        id: install-imagemagick
        run: choco install imagemagick.app -y
      - name: Convert SVG to ICO
        run: |
          if (-not (Test-Path "assets")) { New-Item -ItemType Directory -Path "assets" }
          magick convert "internal/myhome/ui/static/penates.svg" -define icon:auto-resize=256,128,64,48,32,16 "assets/penates.ico"
      - name: Install Inno Setup
        id: install-innosetup
        run: choco install innosetup -y
      - name: Set version in Inno Setup script
        id: inno-version
        run: |
          $content = Get-Content .\myhome.iss -Raw
          $content = $content -replace '#define MyAppVersion "0.0.0"', '#define MyAppVersion "${{ steps.version.outputs.release }}"'
          Set-Content .\myhome.iss -Value $content
      - name: Create dist directory
        run: |
          if (-not (Test-Path "dist")) { New-Item -ItemType Directory -Path "dist" }
      - id: build-installer
        name: Build Windows Installer with Inno Setup
        run: |
          & "C:\Program Files (x86)\Inno Setup 6\ISCC.exe" myhome.iss
          $installer = "myhome-setup-${{ steps.version.outputs.release }}.exe"
          Get-Item "dist\$installer"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "installer_file=$installer"
      - id: find-signtool
        name: Find SignTool.exe
        run: |
          $signtoolPath = Get-ChildItem -Path "${env:ProgramFiles(x86)}\Windows Kits" -Recurse -Filter "signtool.exe" -ErrorAction SilentlyContinue | 
            Where-Object { $_.FullName -match "x64" } | 
            Select-Object -First 1 -ExpandProperty FullName
          
          if (-not $signtoolPath) {
            throw "SignTool.exe not found in Windows Kits directory"
          }
          
          Write-Host "Found SignTool at: $signtoolPath"
          Add-Content -Path $env:GITHUB_OUTPUT -Value "signtool_path=$signtoolPath"
      - id: sign
        name: Sign MSI Package
        env:
          CERTIFICATE_BASE64: ${{ secrets.SIGNING_CERTIFICATE }}
          CERTIFICATE_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}
          SIGNTOOL_PATH: ${{ steps.find-signtool.outputs.signtool_path }}
        run: "try {\n    Write-Host \"Starting certificate processing...\"\n    \n    # Validate certificate data\n    if ([string]::IsNullOrWhiteSpace($env:CERTIFICATE_BASE64)) {\n        throw \"Certificate data is empty\"\n    }\n    \n    Write-Host \"Certificate data length: $($env:CERTIFICATE_BASE64.Length) characters\"\n    \n    # Clean potential issues with base64 string\n    $cleanBase64 = $env:CERTIFICATE_BASE64 -replace '\\s+',''\n    Write-Host \"Cleaned certificate data length: $($cleanBase64.Length) characters\"\n    \n    # Set certificate path before any operations\n    $certPath = $null\n    \n    # Validate base64 format\n    try {\n        $certBytes = [Convert]::FromBase64String($cleanBase64)\n        Write-Host \"Base64 decoded successfully. Byte length: $($certBytes.Length)\"\n        \n        # Validate minimum PFX size (typically at least 1KB)\n        if ($certBytes.Length -lt 1024) {\n            throw \"Decoded certificate data is too small to be a valid PFX file\"\n        }\n        \n        # Ensure temp directory exists\n        $tempDir = [System.IO.Path]::GetTempPath()\n        if (-not (Test-Path $tempDir)) {\n            New-Item -ItemType Directory -Path $tempDir -Force | Out-Null\n        }\n        \n        # Create certificate path\n        $certFileName = [System.Guid]::NewGuid().ToString() + \".pfx\"\n        $certPath = [System.IO.Path]::Combine($tempDir, $certFileName)\n        Write-Host \"Will write certificate to: $certPath\"\n        \n        # Write certificate to file\n        [IO.File]::WriteAllBytes($certPath, $certBytes)\n        \n        if (-not (Test-Path $certPath)) {\n            throw \"Failed to create certificate file at $certPath\"\n        }\n        \n        $fileInfo = Get-Item $certPath\n        Write-Host \"Certificate file created successfully:\"\n        Write-Host \"  Path: $certPath\"\n        Write-Host \"  Size: $($fileInfo.Length) bytes\"\n        Write-Host \"  Last Write Time: $($fileInfo.LastWriteTime)\"\n        \n        # Try loading certificate with explicit flags\n        $flags = [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::Exportable -bor \n                [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::MachineKeySet -bor \n                [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]::PersistKeySet\n        \n        Write-Host \"Attempting to load certificate...\"\n        \n        # Try alternative loading methods if the first one fails\n        try {\n            $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($certPath, $env:CERTIFICATE_PASSWORD, $flags)\n        }\n        catch {\n            Write-Host \"First certificate loading attempt failed: $_\"\n            Write-Host \"Trying alternative loading method...\"\n            $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2\n            $cert.Import($certPath, $env:CERTIFICATE_PASSWORD, $flags)\n        }\n        \n        Write-Host \"Certificate loaded successfully.\"\n        Write-Host \"Certificate Subject: $($cert.Subject)\"\n        Write-Host \"Certificate Issuer: $($cert.Issuer)\"\n        Write-Host \"Certificate Valid From: $($cert.NotBefore)\"\n        Write-Host \"Certificate Valid To: $($cert.NotAfter)\"\n        Write-Host \"Has Private Key: $($cert.HasPrivateKey)\"\n        Write-Host \"Certificate Thumbprint: $($cert.Thumbprint)\"\n        \n        if (-not $cert.HasPrivateKey) {\n            throw \"Certificate does not contain a private key\"\n        }\n        \n        $cert.Dispose()\n        \n        # Sign the MSI using Windows SDK SignTool\n        Write-Host \"Starting MSI signing process...\"\n        $signtool = $env:SIGNTOOL_PATH\n        Write-Host \"SignTool path: $signtool\"\n        \n        if (-not (Test-Path $signtool)) {\n            throw \"SignTool not found at: $signtool\"\n        }\n        \n        Write-Host \"MSI file to sign: ${{ steps.build-msi.outputs.msi_file }}\"\n        \n        # Try signing with more detailed output\n        $result = & $signtool sign /v /debug /f $certPath /p $env:CERTIFICATE_PASSWORD /fd sha256 /tr http://timestamp.digicert.com /td sha256 \"${{ steps.build-msi.outputs.msi_file }}\" 2>&1\n        Write-Host \"SignTool Output: $result\"\n        \n        if ($LASTEXITCODE -ne 0) {\n            Write-Error \"SignTool failed with exit code $LASTEXITCODE\"\n            Write-Error $result\n            throw \"Signing failed\"\n        }\n        \n        Write-Host \"Package signed successfully\"\n    }\n    catch {\n        Write-Error \"Failed during certificate processing: $_\"\n        throw\n    }\n    finally {\n        # Safe cleanup\n        if (-not [string]::IsNullOrWhiteSpace($certPath) -and (Test-Path $certPath)) {\n            Write-Host \"Cleaning up certificate file...\"\n            Remove-Item -Path $certPath -Force -ErrorAction SilentlyContinue\n            Write-Host \"Cleanup completed\"\n        }\n    }\n}\ncatch {\n    Write-Error \"Error during signing process: $_\"\n    Write-Host \"Exception details: $($_.Exception.Message)\"\n    Write-Host \"Stack trace: $($_.Exception.StackTrace)\"\n    throw\n}\nfinally {\n    if (Test-Path $certPath) {\n        Remove-Item $certPath -Force\n        Write-Host \"Certificate file cleaned up\"\n    }\n}\n"
      - name: Upload MyHome Installer as artifact
        uses: actions/upload-artifact@v4
        with:
          name: installer_file
          path: |
            dist/${{ steps.build-installer.outputs.installer_file }}
  release:
    runs-on: ubuntu-latest
    needs:
      - package-deb
      - package-msi
    steps:
      - name: Checkout
        id: checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - id: version
        name: Get package version from ref
        run: |
          # Extract version from the ref input (e.g., refs/tags/v0.5.9 -> 0.5.9)
          REF="${{ github.event.inputs.ref }}"
          VERSION=$(echo "$REF" | sed -E 's|^refs/tags/v*(.*)$|\1|g')
          echo "release=${VERSION}" | tee -a "$GITHUB_OUTPUT"
      - name: Generate Release Notes
        id: release_notes
        uses: gableroux/generate-github-release-notes@v0.1.2
        with:
          repository: ${{ github.repository }}
          base_tag: "${{ github.event.inputs.previous }}"
          head_tag: ${{ github.ref }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
      - name: Download MyHome Installer from package-msi
        uses: actions/download-artifact@v4
        with:
          name: installer_file
      - name: Download MyHome DEB ARM64 from package-deb
        id: deb_file_arm64
        uses: actions/download-artifact@v4
        with:
          name: deb_file_arm64
      - name: Download MyHome DEB AMD64 from package-deb
        id: deb_file_amd64
        uses: actions/download-artifact@v4
        with:
          name: deb_file_amd64
      - name: List files in workspace
        id: list_files
        run: ls -alR
      - name: Release
        id: release
        uses: ncipollo/release-action@v1
        with:
          name: Release ${{ steps.version.outputs.release }}
          artifactErrorsFailBuild: true
          artifacts: "*.deb,${{ needs.package-msi.outputs.installer_file }}"
          tag: v${{ steps.version.outputs.release }}
          prerelease: false
          draft: true
          replacesArtifacts: true
          generateReleaseNotes: true
  merge-back:
    runs-on: ubuntu-latest
    needs:
      - release
    if: github.event.inputs.source_branch != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.inputs.source_branch }}
      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
          git_config_global: true
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_tag_gpgsign: true
      - name: Merge tag back to source branch
        run: |
          set -euo pipefail
          
          SOURCE_BRANCH="${{ github.event.inputs.source_branch }}"
          TAG_REF="${{ github.event.inputs.ref }}"
          
          # Extract tag name from ref (e.g., refs/tags/v0.5.9 -> v0.5.9)
          TAG_NAME=$(echo "$TAG_REF" | sed -E 's|^refs/tags/||')
          
          echo "Merging tag $TAG_NAME back to branch $SOURCE_BRANCH"
          
          # Fetch the tag
          git fetch origin tag "$TAG_NAME"
          
          # Try fast-forward merge first
          if git merge --ff-only "$TAG_NAME"; then
            echo "✓ Fast-forward merge successful"
            MERGE_TYPE="fast-forward"
          else
            # If fast-forward fails, do a regular merge
            echo "⚠ Fast-forward not possible, creating merge commit"
            git merge --no-ff -m "Merge tag '$TAG_NAME' back to $SOURCE_BRANCH" "$TAG_NAME"
            MERGE_TYPE="merge-commit"
          fi
          
          # Push the updated branch
          git push origin "$SOURCE_BRANCH"
          
          echo "✓ Successfully merged $TAG_NAME to $SOURCE_BRANCH ($MERGE_TYPE)"
